

interface Arn {
    arn: String!
}

interface ResourceIdentifier {
    id: String!
    name: String!
}

interface Description {
    description: String
}

enum DataType {
    STRING
    INTEGER
    DOUBLE
    BOOLEAN
    STRUCT
}

enum PropertyType {
    ATTRIBUTE
    MEASUREMENT
    METRIC
    TRANSFORM
}

# im not sure I like this, but its about the only way to make this work
type AttributeValue {
    stringValue: String
    intValue: Int
    floatValue: Float
    booleanValue: Boolean
}

type Property implements ResourceIdentifier {
    id: String!
    name: String!
    #type: PropertyType!
    # if the type is an attribute, a value will be included
    value: AttributeValue
}

type Hierarchy implements ResourceIdentifier {
    id: String!
    name: String!
    childAssetModelId: String!
}

type PropertyDefinition implements ResourceIdentifier{
    id: String!
    name: String!
    propertyType: PropertyType!
    dataType: DataType!
    defaultValue: AttributeValue
    unit: String
}

type HierarchyDefinition {
    id: String
    modelId: String
    name: String
}

type AssetModel implements Arn & ResourceIdentifier & Description {
    arn: String!
    id: String!
    name: String!
    description: String
    properties: [PropertyDefinition]!
    hierarchies: [HierarchyDefinition]!
}

type Asset implements Arn & ResourceIdentifier & Description {
    arn: String!
    id: String!
    name: String!
    description: String
    modelId: String!
    properties: [Property]!
}

type ProjectDescription {
    knowledgeGraphQuery: String!
    assets: [Asset]!
    models: [AssetModel]!
}

input BooleanValueMatch {
    exactMatch: Boolean
}

input IntegerValueMatch {
    exactMatch: Int
}

input DoubleValueMatch {
    exactMatch: Float
}

input StringValueMatch {
    exactMatch: String
}

input AtributeValueMatcher @oneOf {
    booleanMatcher: BooleanValueMatch
    intMatcher: IntegerValueMatch
    doubleMatcher: DoubleValueMatch
    stringMatcher: StringValueMatch
}

input AttributeMatcher {
    name: String
    value: AtributeValueMatcher
}

input ProjectFacet {
    # One or more asset Names that you want to be the root of the project
    assetIds: [String]
    # One or more asset types that you want to be the root of the project
    modelNames: [String]
    # One or more property values that the assets should match
    assetPropertyMatch: [AttributeMatcher]
}

input Project {
    workspaceName: String!
    targets: ProjectFacet
    ancestors: ProjectFacet
    #descendants: ProjectFacet
}

type Query {
    describeProject(project: Project): ProjectDescription!
}
