

interface Arn {
    arn: String!
}

interface ResourceIdentifier {
    id: String!
    name: String!
}

interface Description {
    description: String
}

enum DataType {
    STRING
    INTEGER
    DOUBLE
    BOOLEAN
    STRUCT
}

enum PropertyType {
    ATTRIBUTE
    MEASUREMENT
    METRIC
    TRANSFORM
}

# im not sure I like this, but its about the only way to make this work
type AttributeValue {
    stringValue: String
    intValue: Int
    floatValue: Float
    booleanValue: Boolean
}

type Property implements ResourceIdentifier {
    id: String!
    name: String!
    #type: PropertyType!
    # if the type is an attribute, a value will be included
    value: AttributeValue
}

type Hierarchy implements ResourceIdentifier {
    id: String!
    name: String!
    childAssetModelId: String!
}

type PropertyDefinition implements ResourceIdentifier{
    id: String!
    name: String!
    propertyType: PropertyType!
    dataType: DataType!
    defaultValue: AttributeValue
    unit: String
}

type AssetModel implements Arn & ResourceIdentifier & Description {
    arn: String!
    id: String!
    name: String!
    description: String
    properties: [PropertyDefinition]!
    #hierarchies: [Hierarchy!]!
}

type Asset implements Arn & ResourceIdentifier & Description {
    arn: String!
    id: String!
    name: String!
    description: String
    modelId: String!
    properties: [Property]!
}

type ProjectDescription {
    assets: [Asset]!
    models: [AssetModel]!
}

input Project {
    workspaceName: String!
}

type Query {
    describeProject(project: Project): ProjectDescription!
}
